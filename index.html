<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Application de chat vocal avec visualisation d'onde sonore">
    <meta name="theme-color" content="#121212">
    <title>VoiceWave Chat</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#4F46E5',
                        dark: '#121212',
                        darkgray: '#1A1A1A',
                        darklight: '#222222',
                        accent: '#005AE2',
                        glow: '#0082E6'
                    },
                }
            }
        }
    </script>
    <style>
        /* === STYLES === */
        body {
            touch-action: manipulation;
            overflow: hidden;
            background-color: #121212;
            color: #FFFFFF;
        }
        
        .wave-visualizer {
            position: relative;
            height: 220px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.5s ease;
        }
        
        /* Wave container */
        .ocean {
            height: 120px;
            width: 100%;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            overflow: hidden;
        }
        
        .wave {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="%23333644" fill-opacity="1" d="M0,192L48,197.3C96,203,192,213,288,229.3C384,245,480,267,576,250.7C672,235,768,181,864,181.3C960,181,1056,235,1152,234.7C1248,235,1344,181,1392,154.7L1440,128L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
            position: absolute;
            width: 200%;
            height: 100%;
            animation: wave 15s linear infinite;
            transform: translate3d(0, 0, 0);
            transition: all 0.8s ease;
        }
        
        .wave:nth-of-type(2) {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="%23224488" fill-opacity="0.7" d="M0,64L48,80C96,96,192,128,288,128C384,128,480,96,576,122.7C672,149,768,235,864,266.7C960,299,1056,277,1152,229.3C1248,181,1344,107,1392,69.3L1440,32L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
            animation: wave 12s linear infinite;
            opacity: 0.6;
        }
        
        .wave:nth-of-type(3) {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="%233C4789" fill-opacity="0.4" d="M0,256L48,261.3C96,267,192,277,288,266.7C384,256,480,224,576,213.3C672,203,768,213,864,208C960,203,1056,181,1152,186.7C1248,192,1344,224,1392,240L1440,256L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
            animation: wave 10s linear infinite;
            opacity: 0.4;
        }
        
        @keyframes wave {
            0% {transform: translateX(0);}
            50% {transform: translateX(-25%);}
            100% {transform: translateX(-50%);}
        }
        
        .wave-active .wave {
            animation-duration: calc(15s / var(--intensity, 1));
            height: calc(100% + (35px * var(--intensity, 0)));
        }
        
        .wave-active .wave:nth-of-type(2) {
            animation-duration: calc(12s / var(--intensity, 1));
            height: calc(100% + (25px * var(--intensity, 0)));
        }
        
        .wave-active .wave:nth-of-type(3) {
            animation-duration: calc(10s / var(--intensity, 1));
            height: calc(100% + (15px * var(--intensity, 0)));
        }
        
        .glow-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0;
            background: radial-gradient(
                ellipse at center, 
                rgba(0, 90, 226, 0.3), 
                rgba(79, 70, 229, 0.2) 40%, 
                rgba(28, 84, 187, 0.1) 60%, 
                transparent 80%
            );
            opacity: 0.3;
            filter: blur(15px);
            transition: height 0.8s ease, opacity 0.8s ease;
        }
        
        .wave-active .glow-overlay {
            height: 120px;
            opacity: calc(0.3 + (0.4 * var(--intensity, 0)));
        }
        
        .mic-gradient {
            background: linear-gradient(135deg, #4338CA, #6D28D9);
            transition: all 0.5s ease;
        }
        
        .mic-gradient:hover {
            background: linear-gradient(135deg, #3730A3, #5B21B6);
        }
        
        .mic-listening {
            background: linear-gradient(135deg, #0055E6, #0082E6);
            animation: mic-pulse 2s infinite alternate;
            box-shadow: 0 0 15px 5px rgba(0, 90, 226, 0.3);
        }
        
        @keyframes mic-pulse {
            0% {
                box-shadow: 0 0 10px 2px rgba(0, 90, 226, 0.3);
            }
            100% {
                box-shadow: 0 0 20px 5px rgba(0, 90, 226, 0.5);
            }
        }
        
        .status-text {
            transition: all 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .transcription {
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        /* Chat interface styles */
        .chat-container {
            display: none;
            height: 100%;
            width: 100%;
        }
        
        .chat-messages {
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(156, 163, 175, 0.5) transparent;
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background-color: rgba(156, 163, 175, 0.5);
            border-radius: 20px;
        }
        
        .message {
            max-width: 85%;
            margin-bottom: 10px;
            padding: 12px 16px;
            border-radius: 18px;
        }
        
        .user-message {
            background-color: #4F46E5;
            color: white;
            border-top-right-radius: 4px;
            align-self: flex-end;
        }
        
        .system-message {
            background-color: #222222;
            color: #F3F4F6;
            border-top-left-radius: 4px;
            align-self: flex-start;
        }

        /* Enhanced chat input styles */
        .chat-input-container {
            background-color: #222222;
            border-radius: 28px;
            padding: 8px 8px 8px 20px;
            display: flex;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            margin: 0 4px;
            border: 2px solid transparent;
        }
        
        .chat-input-container:focus-within {
            border-color: #4F46E5;
            box-shadow: 0 2px 15px rgba(79, 70, 229, 0.15);
        }
        
        .chat-input {
            flex: 1;
            background: transparent;
            border: none;
            outline: none;
            font-size: 16px;
            color: #F3F4F6;
            padding: 8px 0;
        }
        
        .chat-send-button {
            background: linear-gradient(135deg, #4338CA, #6D28D9);
            color: white;
            border-radius: 50%;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transform: scale(1);
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .chat-send-button:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #3730A3, #5B21B6);
        }
        
        .chat-send-button:active {
            transform: scale(0.95);
        }
        
        .chat-send-button svg {
            width: 20px;
            height: 20px;
        }

        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(79, 70, 229, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(79, 70, 229, 0);
            }
        }

        /* Animation classes */
        .slide-in {
            animation: slideIn 0.4s forwards cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        .slide-out {
            animation: slideOut 0.4s forwards cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(-100%); opacity: 0; }
        }

        /* Install prompt */
        #install-prompt {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #222222;
            border: 1px solid #4F46E5;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 90%;
            width: 340px;
            z-index: 100;
            display: none;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
            .dark\:bg-darkgray {
                background-color: #1A1A1A;
            }
            
            .dark\:text-white {
                color: #FFFFFF;
            }
        }
    </style>
</head>

<body class="bg-dark text-white">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="fixed top-0 inset-x-0 py-4 px-4 flex items-center justify-between bg-dark/90 backdrop-blur-md z-20">
            <div class="flex items-center">
                <div class="relative mr-2 h-6 w-6">
                    <div class="absolute inset-0 rounded-full bg-primary opacity-25"></div>
                    <div class="relative rounded-full h-6 w-6 bg-primary flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                    </div>
                </div>
                <h1 class="text-xl font-bold text-white" id="app-title">VoiceWave Chat</h1>
            </div>
            
            <button id="mode-toggle" class="h-10 w-10 bg-primary rounded-full flex items-center justify-center focus:outline-none shadow-md transform transition-all duration-300 ease-in-out active:scale-95 hover:bg-opacity-90">
                <!-- Chat icon (shown in voice mode) -->
                <svg id="chat-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 10h.01M12 10h.01M16 10h.01M9 16H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-5l-5 5v-5z" />
                </svg>
                <!-- Mic icon (shown in chat mode) -->
                <svg id="mic-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                </svg>
            </button>
        </header>

        <!-- Voice interface -->
        <main id="voice-interface" class="flex-1 pt-16 pb-32 flex flex-col">
            <!-- Text display area -->
            <div class="flex-1 flex flex-col items-center justify-center px-6">
                <!-- Current status -->
                <div id="status-text" class="text-xl font-medium text-white text-center mb-4 status-text">
                    Appuyez pour parler
                </div>
                
                <!-- Real-time transcription - displays what's being heard -->
                <div id="transcription" class="text-2xl text-gray-200 text-center max-w-lg transcription mt-6 mb-6 min-h-[100px]"></div>
            </div>

            <!-- Audio Visualizer -->
            <div class="mt-auto">
                <div id="wave-visualizer" class="wave-visualizer">
                    <!-- Wave Animation Container -->
                    <div class="ocean">
                        <div class="wave"></div>
                        <div class="wave"></div>
                        <div class="wave"></div>
                        <div class="glow-overlay"></div>
                    </div>
                </div>
                
                <!-- Control buttons -->
                <div class="flex justify-center items-center gap-6 mb-20 mt-8">
                    <button id="cancel-button" class="h-16 w-16 bg-red-500 rounded-full flex items-center justify-center focus:outline-none shadow-lg transform transition-all duration-300 ease-in-out active:scale-95 hover:bg-red-600">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                    
                    <button id="mic-button" class="h-20 w-20 mic-gradient rounded-full flex items-center justify-center focus:outline-none shadow-lg transform transition-all duration-300 ease-in-out active:scale-95">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                    </button>
                </div>
            </div>
        </main>

        <!-- Chat interface -->
        <main id="chat-interface" class="chat-container flex-1 pt-16 pb-6 flex flex-col">
            <!-- Chat messages area -->
            <div class="chat-messages flex-1 flex flex-col px-4 py-2 overflow-y-auto mb-2">
                <div class="message system-message">
                    Bienvenue dans le chat ! Comment puis-je vous aider ?
                </div>
                <!-- Messages will be added here dynamically -->
            </div>
            
            <!-- Chat input area - positioned at bottom with space -->
            <div class="px-4 pt-2 pb-8 shadow-md bg-dark/90 backdrop-blur-sm sticky bottom-0 z-10 mt-auto">
                <div id="chat-input-container" class="chat-input-container">
                    <input 
                        id="message-input" 
                        class="chat-input" 
                        placeholder="Écrivez votre message..." 
                        type="text"
                    />
                    <button id="send-message" class="chat-send-button">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 12h14m-7-7l7 7-7 7" />
                        </svg>
                    </button>
                </div>
            </div>
        </main>
        
        <!-- Install Prompt -->
        <div id="install-prompt" class="text-white">
            <div class="flex justify-between items-start mb-3">
                <div class="font-bold text-lg">Installer l'application</div>
                <button id="close-prompt" class="text-gray-400 hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
            <p class="text-gray-300 mb-4">Installez VoiceWave sur votre appareil pour une expérience optimale, même hors ligne.</p>
            <div class="flex space-x-3">
                <button id="install-button" class="bg-primary hover:bg-primary/90 text-white px-4 py-2 rounded-lg flex-grow">Installer</button>
                <button id="install-later" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Plus tard</button>
            </div>
        </div>
    </div>

    <script>
        // === SERVICE WORKER REGISTRATION ===
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Create an inline service worker with improved caching
                const swCode = `
                    const CACHE_NAME = 'voicewave-cache-v1';
                    const STATIC_RESOURCES = [
                        './',
                        './index.html',
                        './manifest.json'
                    ];

                    // Install event - cache static resources
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => {
                                    console.log('Service Worker: Caching static files');
                                    return cache.addAll(STATIC_RESOURCES);
                                })
                                .then(() => self.skipWaiting()) // Force service worker activation
                        );
                    });

                    // Activate event - clean up old caches
                    self.addEventListener('activate', (event) => {
                        event.waitUntil(
                            caches.keys().then((cacheNames) => {
                                return Promise.all(
                                    cacheNames.filter((cacheName) => {
                                        return cacheName !== CACHE_NAME;
                                    }).map((cacheName) => {
                                        console.log('Service Worker: Removing old cache', cacheName);
                                        return caches.delete(cacheName);
                                    })
                                );
                            }).then(() => self.clients.claim()) // Take control of clients immediately
                        );
                    });

                    // Fetch event - serve from cache or network
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then((cachedResponse) => {
                                    // Return cached response if available
                                    if (cachedResponse) {
                                        return cachedResponse;
                                    }
                                    
                                    // Otherwise fetch from network
                                    return fetch(event.request)
                                        .then((networkResponse) => {
                                            // Don't cache non-successful responses or non-GET requests
                                            if (!networkResponse || networkResponse.status !== 200 || event.request.method !== 'GET') {
                                                return networkResponse;
                                            }
                                            
                                            // Clone the response to cache it and return it
                                            const responseToCache = networkResponse.clone();
                                            caches.open(CACHE_NAME)
                                                .then((cache) => {
                                                    cache.put(event.request, responseToCache);
                                                });
                                                
                                            return networkResponse;
                                        })
                                        .catch((error) => {
                                            console.error('Service Worker: Fetch error', error);
                                            // You could return a custom offline page here
                                        });
                                })
                        );
                    });
                `;

                const swBlob = new Blob([swCode], { type: 'text/javascript' });
                const swURL = URL.createObjectURL(swBlob);

                navigator.serviceWorker.register(swURL)
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }

        // Create manifest.json and serve it
        const manifestContent = {
            "name": "VoiceWave Chat",
            "short_name": "VoiceWave",
            "description": "Application de chat vocal avec visualisation d'ondes sonores",
            "start_url": "/",
            "display": "standalone",
            "background_color": "#121212",
            "theme_color": "#121212",
            "orientation": "portrait",
            "categories": ["productivity", "communication"],
            "icons": [
                {
                    "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0iIzRGNDZFNSIvPjxwYXRoIGZpbGw9IiNGRkYiIGQ9Ik02NSA1MGMwIDguMy02LjcgMTUtMTUgMTVzLTE1LTYuNy0xNS0xNSA2LjctMTUgMTUtMTUgMTUgNi43IDE1IDE1em0tNy41IDBjMC00LjEtMy40LTcuNS03LjUtNy41cy03LjUgMy40LTcuNSA3LjUgMy40IDcuNSA3LjUgNy41IDcuNS0zLjQgNy41LTcuNXpNNzMuMyAyNi43Yy0zLjMtMy4zLTguNy0zLjMtMTIgMEw1MCA0MWwtMTEuMy0xMS4zYy0zLjMtMy4zLTguNy0zLjMtMTIgMHMtMy4zIDguNyAwIDEybDE3LjQgMTcuNGMzLjMgMy4zIDguNyAzLjMgMTIgMEw3My4zIDM4LjdjMy4zLTMuMyAzLjMtOC43IDAtMTJ6Ii8+PC9zdmc+",
                    "sizes": "512x512",
                    "type": "image/svg+xml",
                    "purpose": "any"
                },
                {
                    "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgZmlsbD0iIzRGNDZFNSIvPjxwYXRoIGZpbGw9IiNGRkYiIGQ9Ik02NSA1MGMwIDguMy02LjcgMTUtMTUgMTVzLTE1LTYuNy0xNS0xNSA2LjctMTUgMTUtMTUgMTUgNi43IDE1IDE1em0tNy41IDBjMC00LjEtMy40LTcuNS03LjUtNy41cy03LjUgMy40LTcuNSA3LjUgMy40IDcuNSA3LjUgNy41IDcuNS0zLjQgNy41LTcuNXpNNzMuMyAyNi43Yy0zLjMtMy4zLTguNy0zLjMtMTIgMEw1MCA0MWwtMTEuMy0xMS4zYy0zLjMtMy4zLTguNy0zLjMtMTIgMHMtMy4zIDguNyAwIDEybDE3LjQgMTcuNGMzLjMgMy4zIDguNyAzLjMgMTIgMEw3My4zIDM4LjdjMy4zLTMuMyAzLjMtOC43IDAtMTJ6Ii8+PC9zdmc+",
                    "sizes": "192x192",
                    "type": "image/svg+xml",
                    "purpose": "maskable"
                }
            ],
            "shortcuts": [
                {
                    "name": "Voice Mode",
                    "short_name": "Voice",
                    "description": "Démarrer en mode vocal",
                    "url": "/?mode=voice"
                },
                {
                    "name": "Chat Mode",
                    "short_name": "Chat",
                    "description": "Démarrer en mode chat",
                    "url": "/?mode=chat"
                }
            ],
            "screenshots": [
                {
                    "src": "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTIgODU2IiBmaWxsPSJub25lIj48cmVjdCB3aWR0aD0iMzkyIiBoZWlnaHQ9Ijg1NiIgZmlsbD0iIzEyMTIxMiIvPjxyZWN0IHk9IjY1NiIgd2lkdGg9IjM5MiIgaGVpZ2h0PSIyMDAiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8xXzE2KSIvPjxjaXJjbGUgY3g9IjE5NiIgY3k9IjU3NiIgcj0iODAiIGZpbGw9IiM0RjQ2RTUiLz48cGF0aCBkPSJNMjMwIDU3NkMyMzAgNTk1LjMzIDIxNC4zMyA2MTEgMTk1IDYxMUMxNzUuNjcgNjExIDE2MCA1OTUuMzMgMTYwIDU3NkMxNjAgNTU2LjY3IDE3NS42NyA1NDEgMTk1IDU0MUMyMTQuMzMgNTQxIDIzMCA1NTYuNjcgMjMwIDU3NlpNMjE3LjUgNTc2QzIxNy41IDU2My41NCAyMDcuNDYgNTUzLjUgMTk1IDU1My41QzE4Mi41NCA1NTMuNSAxNzIuNSA1NjMuNTQgMTcyLjUgNTc2QzE3Mi41IDU4OC40NiAxODIuNTQgNTk4LjUgMTk1IDU5OC41QzIwNy40NiA1OTguNSAyMTcuNSA1ODguNDYgMjE3LjUgNTc2Wk0yNDguMyA1MjIuN0MyMzguNyA1MTMuMSAyMjMuMyA1MTMuMSAyMTMuNyA1MjIuN0wxOTUgNTQxTDE3Ni4zIDUyMi43QzE2Ni43IDUxMy4xIDE1MS4zIDUxMy4xIDE0MS43IDUyMi43QzEzMi4xIDUzMi4zIDEzMi4xIDU0Ny43IDE0MS43IDU1Ny4zTDE3Ni43IDU5Mi4zQzE4Ni4zIDYwMS45IDIwMS43IDYwMS45IDIxMS4zIDU5Mi4zTDI0Ni4zIDU1Ny4zQzI1NS45IDU0Ny43IDI1NS45IDUzMi4zIDI0Ni4zIDUyMi43SDI0OC4zWiIgZmlsbD0id2hpdGUiLz48ZGVmcz48bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMV8xNiIgeDE9IjE5NiIgeTE9IjY1NiIgeDI9IjE5NiIgeTI9Ijg1NiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPjxzdG9wIHN0b3AtY29sb3I9IiMxMjEyMTIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMyMjQ0ODgiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48L3N2Zz4=",
                    "sizes": "392x856",
                    "type": "image/svg+xml",
                    "form_factor": "narrow"
                }
            ],
            "related_applications": [],
            "prefer_related_applications": false
        };

        const manifestBlob = new Blob([JSON.stringify(manifestContent)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('link[rel="manifest"]').href = manifestURL;

        // === PWA INSTALL PROMPT ===
        let deferredPrompt;
        const installPrompt = document.getElementById('install-prompt');
        const installButton = document.getElementById('install-button');
        const closePromptButton = document.getElementById('close-prompt');
        const installLaterButton = document.getElementById('install-later');

        window.addEventListener('beforeinstallprompt', (e) => {
            // Prevent Chrome 67 and earlier from automatically showing the prompt
            e.preventDefault();
            // Stash the event so it can be triggered later
            deferredPrompt = e;
            // Show the install prompt
            setTimeout(() => {
                installPrompt.style.display = 'block';
            }, 3000);
        });

        installButton.addEventListener('click', () => {
            // Hide the app provided install promotion
            installPrompt.style.display = 'none';
            // Show the install prompt
            deferredPrompt.prompt();
            // Wait for the user to respond to the prompt
            deferredPrompt.userChoice.then((choiceResult) => {
                if (choiceResult.outcome === 'accepted') {
                    console.log('User accepted the install prompt');
                } else {
                    console.log('User dismissed the install prompt');
                }
                deferredPrompt = null;
            });
        });

        closePromptButton.addEventListener('click', () => {
            installPrompt.style.display = 'none';
        });

        installLaterButton.addEventListener('click', () => {
            installPrompt.style.display = 'none';
        });

        // === DARK MODE SUPPORT ===
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // === CONFIGURATION ===
        const config = {
            visualization: {
                analyserFftSize: 2048,
                smoothingTimeConstant: 0.85,
                minIntensity: 1,      // Minimum wave animation intensity
                maxIntensity: 2.5,    // Maximum wave animation intensity
                silenceThreshold: 35, // Threshold for considering audio as silence (0-255)
                intensityUpdateInterval: 100 // How often to update wave intensity in ms
            },
            messages: {
                idle: "Appuyez pour parler",
                listening: "Je vous écoute",
                processing: "Traitement en cours..."
            }
        };

        // === INITIALISATIONS ===
        
        // DOM elements
        const elements = {
            micButton: document.getElementById('mic-button'),
            cancelButton: document.getElementById('cancel-button'),
            waveVisualizer: document.getElementById('wave-visualizer'),
            statusText: document.getElementById('status-text'),
            transcription: document.getElementById('transcription'),
            
            // Wave elements
            ocean: document.querySelector('.ocean'),
            waves: document.querySelectorAll('.wave'),
            glowOverlay: document.querySelector('.glow-overlay'),
            
            // Mode toggle elements
            modeToggle: document.getElementById('mode-toggle'),
            chatIcon: document.getElementById('chat-icon'),
            micIcon: document.getElementById('mic-icon'),
            
            // Interface elements
            voiceInterface: document.getElementById('voice-interface'),
            chatInterface: document.getElementById('chat-interface'),
            
            // Chat interface elements
            messageInput: document.getElementById('message-input'),
            sendMessage: document.getElementById('send-message'),
            chatInputContainer: document.getElementById('chat-input-container'),
            chatMessages: document.querySelector('.chat-messages'),
            appTitle: document.getElementById('app-title')
        };
        
        // State variables
        const state = {
            isListening: false,
            recognition: null,
            audioContext: null,
            analyser: null,
            microphone: null,
            dataArray: null,
            
            // Audio stream and monitoring
            audioStream: null,
            microphoneActive: false,
            
            // Wave animation state
            currentIntensity: 1,
            intensityInterval: null,
            waveActive: false,
            
            // Chat state
            currentMode: 'voice', // 'voice' or 'chat'
            messages: [] // To store chat messages
        };
        
        // === VOICE RECOGNITION AND AUDIO ANALYSIS ===
        
        // Initialize Web Speech API for voice recognition
        function setupSpeechRecognition() {
            // Check browser support
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.warn("Speech recognition is not supported in this browser");
                alert("La reconnaissance vocale n'est pas prise en charge par votre navigateur");
                return false;
            }
            
            // Create recognition object
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            state.recognition = new SpeechRecognition();
            
            // Configuration
            state.recognition.lang = 'fr-FR';
            state.recognition.continuous = true;
            state.recognition.interimResults = true;
            
            // Event handlers
            state.recognition.onstart = () => {
                state.isListening = true;
                updateListeningState(true);
            };
            
            state.recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                // Collect results
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Display complete text (both final and interim)
                elements.transcription.textContent = finalTranscript + interimTranscript;
            };
            
            state.recognition.onerror = (event) => {
                console.error("Speech recognition error:", event.error);
                if (event.error === 'no-speech') {
                    // Just a notification, not a critical error
                    console.log("No speech detected");
                } else if (event.error === 'audio-capture' || event.error === 'network') {
                    // These are more serious errors, might need to stop
                    stopListening();
                }
            };
            
            state.recognition.onend = () => {
                console.log("Recognition ended");
                
                // Restart if still in listening mode (important for continuous listening)
                if (state.isListening) {
                    try {
                        state.recognition.start();
                        console.log("Recognition restarted");
                    } catch (e) {
                        console.log("Could not restart recognition:", e);
                    }
                }
            };
            
            return true;
        }
        
        // Set up audio analysis for visualization
        async function setupAudioAnalysis() {
            try {
                // Check support
                if (!('AudioContext' in window) && !('webkitAudioContext' in window)) {
                    console.warn("Web Audio API is not supported in this browser");
                    return false;
                }
                
                // Create audio context
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                state.audioContext = new AudioContext();
                
                // Request microphone access
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.audioStream = stream;
                state.microphoneActive = true;
                
                // Connect microphone to analyzer
                state.microphone = state.audioContext.createMediaStreamSource(stream);
                state.analyser = state.audioContext.createAnalyser();
                
                // Configure analyzer
                state.analyser.fftSize = config.visualization.analyserFftSize;
                state.analyser.smoothingTimeConstant = config.visualization.smoothingTimeConstant;
                
                // Prepare data array for analysis
                const bufferLength = state.analyser.frequencyBinCount;
                state.dataArray = new Uint8Array(bufferLength);
                
                // Connect nodes
                state.microphone.connect(state.analyser);
                
                return true;
            } catch (error) {
                console.error("Error initializing audio analysis:", error);
                return false;
            }
        }
        
        // Start monitoring audio levels and update wave intensity
        function startAudioMonitoring() {
            if (!state.analyser) return;
            
            // Add active class to waves
            elements.ocean.parentElement.classList.add('wave-active');
            state.waveActive = true;
            
            // Set initial intensity
            setWaveIntensity(config.visualization.minIntensity);
            
            // Start intensity monitoring
            state.intensityInterval = setInterval(() => {
                if (!state.isListening || !state.analyser) {
                    clearInterval(state.intensityInterval);
                    state.intensityInterval = null;
                    return;
                }
                
                // Get frequency data for volume calculation
                state.analyser.getByteFrequencyData(state.dataArray);
                
                // Calculate average volume
                let sum = 0;
                for (let i = 0; i < state.dataArray.length; i++) {
                    sum += state.dataArray[i];
                }
                const average = sum / state.dataArray.length;
                
                // Map the average to an intensity value that works well for animation
                let intensity;
                if (average < config.visualization.silenceThreshold) {
                    // If below threshold, go to minimum intensity (calm state)
                    intensity = config.visualization.minIntensity;
                } else {
                    // Otherwise, map it to our range - apply curve for smoother response
                    const normalized = Math.min(1, (average - config.visualization.silenceThreshold) / (255 - config.visualization.silenceThreshold));
                    intensity = config.visualization.minIntensity + 
                                normalized * 
                                (config.visualization.maxIntensity - config.visualization.minIntensity);
                    
                    // Apply a curve for better visual response
                    intensity = config.visualization.minIntensity + 
                                Math.pow(normalized, 1.5) * 
                                (config.visualization.maxIntensity - config.visualization.minIntensity);
                }
                
                // Apply the intensity with smoothing
                setWaveIntensity(intensity);
            }, config.visualization.intensityUpdateInterval);
        }
        
        // Set the wave animation intensity
        function setWaveIntensity(intensity) {
            // Smooth transition by limiting change per update
            const maxChange = 0.2;
            const diff = intensity - state.currentIntensity;
            const change = Math.min(Math.abs(diff), maxChange) * (diff > 0 ? 1 : -1);
            
            state.currentIntensity = state.currentIntensity + change;
            elements.ocean.style.setProperty('--intensity', state.currentIntensity);
        }
        
        // Stop audio monitoring and reset waves
        function stopAudioMonitoring() {
            if (state.intensityInterval) {
                clearInterval(state.intensityInterval);
                state.intensityInterval = null;
            }
            
            // Reset wave appearance gradually
            const resetInterval = setInterval(() => {
                if (state.currentIntensity > config.visualization.minIntensity) {
                    state.currentIntensity -= 0.1;
                    elements.ocean.style.setProperty('--intensity', state.currentIntensity);
                } else {
                    clearInterval(resetInterval);
                    elements.ocean.parentElement.classList.remove('wave-active');
                    state.waveActive = false;
                }
            }, 100);
        }
        
        // === VOICE INPUT MANAGEMENT ===
        
        // Start voice listening with robust error handling
        async function startListening() {
            try {
                // Clear previous transcript
                elements.transcription.textContent = "";
                
                // First-time initialization
                if (!state.analyser && !state.recognition) {
                    // Set up audio processing
                    const recognitionReady = setupSpeechRecognition();
                    const analysisReady = await setupAudioAnalysis();
                    
                    if (!recognitionReady || !analysisReady) {
                        alert("Impossible d'initialiser la reconnaissance vocale ou l'analyse audio");
                        return;
                    }
                } else if (state.audioContext && state.audioContext.state === 'suspended') {
                    // Resume audio context if suspended
                    await state.audioContext.resume();
                }
                
                // Set listening state
                state.isListening = true;
                
                // Start voice recognition
                try {
                    if (state.recognition) {
                        state.recognition.start();
                    }
                } catch (error) {
                    console.warn("Recognition already started or error:", error);
                    
                    // Try to stop and restart if it's already running
                    try {
                        state.recognition.stop();
                        setTimeout(() => {
                            state.recognition.start();
                        }, 200);
                    } catch (e) {
                        console.error("Could not restart recognition:", e);
                    }
                }
                
                // Start audio monitoring for wave animation
                startAudioMonitoring();
                
                // Update UI state
                updateListeningState(true);
            } catch (error) {
                console.error("Error in startListening:", error);
                stopListening(); // Clean up if there's an error
                alert("Une erreur s'est produite lors de l'activation du microphone.");
            }
        }
        
        // Stop voice listening with reliable cleanup
        function stopListening() {
            // Update state
            state.isListening = false;
            
            // Stop recognition if active
            if (state.recognition) {
                try {
                    state.recognition.stop();
                } catch (error) {
                    console.log("Recognition was already stopped");
                }
            }
            
            // Stop audio monitoring
            stopAudioMonitoring();
            
            // Update UI
            updateListeningState(false);
        }
        
        // Update UI based on listening state
        function updateListeningState(isListening) {
            // Update status text
            elements.statusText.textContent = isListening ? 
                config.messages.listening : 
                config.messages.idle;
            
            // Clear transcription with delay (for better UX)
            if (!isListening) {
                setTimeout(() => {
                    if (!state.isListening) {
                        elements.transcription.textContent = "";
                    }
                }, 500);
            }
            
            // Update button appearance
            if (isListening) {
                elements.micButton.classList.add("mic-listening");
            } else {
                elements.micButton.classList.remove("mic-listening");
            }
        }
        
        // === CHAT FUNCTIONS ===
        
        // Switch between voice and chat interfaces
        function switchMode(mode) {
            if (mode === state.currentMode) return;
            
            // Stop listening if switching from voice mode
            if (state.currentMode === 'voice' && state.isListening) {
                stopListening();
            }
            
            // Update title and toggle button icons
            if (mode === 'voice') {
                elements.appTitle.textContent = 'VoiceWave Chat';
                elements.chatIcon.classList.remove('hidden');
                elements.micIcon.classList.add('hidden');
                
                // Slide out chat interface
                elements.chatInterface.classList.add('slide-out');
                
                // Wait for animation to complete
                setTimeout(() => {
                    elements.chatInterface.style.display = 'none';
                    elements.chatInterface.classList.remove('slide-out');
                    
                    // Show voice interface
                    elements.voiceInterface.style.display = 'flex';
                    elements.voiceInterface.classList.add('slide-in');
                    
                    setTimeout(() => {
                        elements.voiceInterface.classList.remove('slide-in');
                    }, 400);
                }, 400);
            } else {
                elements.appTitle.textContent = 'Chat Écrit';
                elements.chatIcon.classList.add('hidden');
                elements.micIcon.classList.remove('hidden');
                
                // Slide out voice interface
                elements.voiceInterface.classList.add('slide-out');
                
                // Wait for animation to complete
                setTimeout(() => {
                    elements.voiceInterface.style.display = 'none';
                    elements.voiceInterface.classList.remove('slide-out');
                    
                    // Show chat interface
                    elements.chatInterface.style.display = 'flex';
                    elements.chatInterface.classList.add('slide-in');
                    
                    // Focus input
                    elements.messageInput.focus();
                    
                    setTimeout(() => {
                        elements.chatInterface.classList.remove('slide-in');
                    }, 400);
                }, 400);
            }
            
            // Update current mode
            state.currentMode = mode;
        }
        
        // Add a new message to the chat
        function addMessage(text, isUser = true) {
            // Create message element
            const messageEl = document.createElement('div');
            messageEl.className = isUser ? 
                'message user-message self-end' : 
                'message system-message self-start';
            messageEl.textContent = text;
            
            // Add to DOM
            elements.chatMessages.appendChild(messageEl);
            
            // Store in state
            state.messages.push({
                text,
                isUser
            });
            
            // Scroll to bottom
            elements.chatMessages.scrollTop = elements.chatMessages.scrollHeight;
        }
        
        // Handle sending a message
        function sendMessage() {
            const text = elements.messageInput.value.trim();
            if (!text) return;
            
            // Add visual feedback - pulse animation
            elements.chatInputContainer.classList.add('pulse-animation');
            
            // Add user message
            addMessage(text, true);
            
            // Clear input
            elements.messageInput.value = '';
            
            // Remove pulse animation after a short delay
            setTimeout(() => {
                elements.chatInputContainer.classList.remove('pulse-animation');
            }, 300);
            
            // Add automatic response (in a real app, this would be an API call)
            setTimeout(() => {
                addMessage(`Je comprends votre message : "${text}"`, false);
            }, 500);
        }
        
        // === INITIALIZATION AND EVENT HANDLERS ===
        
        // Initialize the application
        function initializeApp() {
            // Voice button events
            elements.micButton.addEventListener('click', () => {
                if (!state.isListening) {
                    startListening();
                } else {
                    stopListening();
                }
            });
            
            elements.cancelButton.addEventListener('click', () => {
                stopListening();
            });
            
            // Mode toggle button
            elements.modeToggle.addEventListener('click', () => {
                if (state.currentMode === 'voice') {
                    switchMode('chat');
                } else {
                    switchMode('voice'); 
                }
            });
            
            // Send message button
            elements.sendMessage.addEventListener('click', sendMessage);
            
            // Dynamic input effects
            elements.messageInput.addEventListener('focus', () => {
                elements.chatInputContainer.classList.add('shadow-lg');
            });
            
            elements.messageInput.addEventListener('blur', () => {
                elements.chatInputContainer.classList.remove('shadow-lg');
            });
            
            // Send message on Enter key
            elements.messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            // Add dynamic effect when typing
            elements.messageInput.addEventListener('input', () => {
                if (elements.messageInput.value.trim() !== '') {
                    elements.sendMessage.classList.add('scale-110');
                } else {
                    elements.sendMessage.classList.remove('scale-110');
                }
            });
            
            // Handle URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('mode') === 'chat') {
                switchMode('chat');
            }
            
            // Prevent app from going to sleep when active
            if ('wakeLock' in navigator) {
                // Try to acquire a wakelock when the user interacts with the mic
                elements.micButton.addEventListener('click', async () => {
                    if (state.isListening) {
                        try {
                            const wakeLock = await navigator.wakeLock.request('screen');
                            
                            // Release the wakelock when the mic is stopped
                            wakeLock.addEventListener('release', () => {
                                console.log('Wake Lock released');
                            });
                            
                            // Also release it when the user leaves the page
                            document.addEventListener('visibilitychange', () => {
                                if (document.visibilityState === 'hidden' && wakeLock) {
                                    wakeLock.release();
                                }
                            });
                        } catch (err) {
                            console.log(`Wake Lock error: ${err.name}, ${err.message}`);
                        }
                    }
                });
            }
            
            // Make sure the visualization works after the app returns from background
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && state.isListening) {
                    // Resume the audio context if it got suspended
                    if (state.audioContext && state.audioContext.state === 'suspended') {
                        state.audioContext.resume();
                    }
                }
            });
        }
        
        // Start the application
        initializeApp();
    </script>
</body>
</html>
